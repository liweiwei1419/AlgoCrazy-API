以前中央电视台有个节目叫「幸运 52」，里面有个猜价格游戏。游戏是这么玩的：当主持人展示一款商品时，选手猜测价格为 50 元，主持人提示「价格低了」，选手根据这一信息，再次猜测价格为 70 元，主持人又提示「价格高了」，选手继续调整价格猜测，如此反复，直到猜出正确价格或用完规定的猜测次数。猜价格的策略就应用了「二分查找」的思想：减而治之，即：逐渐减少搜索区间，然后处理之。

查字典其实也用到了二分查找的思想。<font style="color:rgb(31, 35, 41);">先翻到（大致的）中间页，将该页首字与目标字对比。若首字比目标字靠后，往前翻；若靠前，往后翻。不断如此，定位目标字。</font>

<font style="color:rgb(31, 35, 41);">我们</font>这一节向大家介绍两道非常基础的二分查找问题，它们是：

+ 「力扣」第 374 题：猜数字大小（简单）；
+ 「力扣」第 704 题：二分查找（简单）。

# 例题 1：「力扣」第 374 题：猜数字大小（简单）
+ 题目链接：[https://leetcode.cn/problems/guess-number-higher-or-lower/description/](https://leetcode.cn/problems/guess-number-higher-or-lower/description/)

<font style="color:rgb(38, 38, 38);">我们正在玩猜数字游戏。猜数字游戏的规则如下：</font>

<font style="color:rgb(38, 38, 38);">我会从 </font>`<font style="color:rgba(38, 38, 38, 0.75);">1</font>`<font style="color:rgb(38, 38, 38);"> 到 </font>`<font style="color:rgba(38, 38, 38, 0.75);">n</font>`<font style="color:rgb(38, 38, 38);"> </font><font style="color:rgb(38, 38, 38);">随机选择一个数字。 请你猜选出的是哪个数字。</font>

<font style="color:rgb(38, 38, 38);">如果你猜错了，我会告诉你，我选出的数字比你猜测的数字大了还是小了。</font>

<font style="color:rgb(38, 38, 38);">你可以通过调用一个预先定义好的接口</font><font style="color:rgb(38, 38, 38);"> </font>`<font style="color:rgba(38, 38, 38, 0.75);">int guess(int num)</font>`<font style="color:rgb(38, 38, 38);"> </font><font style="color:rgb(38, 38, 38);">来获取猜测结果，返回值一共有三种可能的情况：</font>

+ `<font style="color:rgba(38, 38, 38, 0.75);">-1</font>`<font style="color:rgb(38, 38, 38);">：你猜的数字比我选出的数字大 （即 </font>`<font style="color:rgba(38, 38, 38, 0.75);">num > pick</font>`<font style="color:rgb(38, 38, 38);">）。</font>
+ `<font style="color:rgba(38, 38, 38, 0.75);">1</font>`<font style="color:rgb(38, 38, 38);">：你猜的数字比我选出的数字小 （即 </font>`<font style="color:rgba(38, 38, 38, 0.75);">num < pick</font>`<font style="color:rgb(38, 38, 38);">）。</font>
+ `<font style="color:rgba(38, 38, 38, 0.75);">0</font>`<font style="color:rgb(38, 38, 38);">：你猜的数字与我选出的数字相等。（即 </font>`<font style="color:rgba(38, 38, 38, 0.75);">num == pick</font>`<font style="color:rgb(38, 38, 38);">）。</font>

<font style="color:rgb(38, 38, 38);">返回我选出的数字。</font>

**<font style="color:rgb(38, 38, 38);">示例 1：</font>**

```plain
输入：n = 10, pick = 6
输出：6
```

**<font style="color:rgb(38, 38, 38);">示例 2：</font>**

```plain
输入：n = 1, pick = 1
输出：1
```

**<font style="color:rgb(38, 38, 38);">示例 3：</font>**

```plain
输入：n = 2, pick = 1
输出：1
```

**<font style="color:rgb(38, 38, 38);">提示：</font>**

+ `<font style="color:rgba(38, 38, 38, 0.75);">1 <= n <= 2</font><sup><font style="color:rgba(38, 38, 38, 0.75);">31</font></sup><font style="color:rgba(38, 38, 38, 0.75);"> - 1</font>`
+ `<font style="color:rgba(38, 38, 38, 0.75);">1 <= pick <= n</font>`

## 思路分析
本题其实就是「猜价格游戏」，是二分查找最开始的样子：**查找一个有范围的整数**。

题目中的「我」是「出题人」，而「你」是「我们编写的程序」，大家区分清楚就好。题目要猜的数在 1 到 `n` 之间，于是初始化两个变量，`left = 1` 和 `right = n`，表示当前搜索的左右边界。每次循环计算中间值 `mid = (left + righ) / 2`（此处 `mid` 是 `<font style="color:rgba(0, 0, 0, 0.85);">middle</font>`<font style="color:rgba(0, 0, 0, 0.85);"> 的简写</font>），调用函数 `guess(mid)` 来判断 `mid` 是否是要猜的数字：

+ 如果 `guess(mid) == 0`，说明猜对了，返回`mid`；
+ 如果 `guess(mid) == -1`，题目说「你猜的数字比我选出的数字大」，所以「我们编写的程序」猜大了，下一轮应该往小了猜，因此将 `right` 更新为 `mid - 1`，设置 `right = mid - 1`；
+ 如果 `guess(mid) = 1`，题目说「你猜的数字比我选出的数字小」，说明「我们编写的程序」猜小了，下一轮应该往大了猜，因此将 `left` 更新为 `mid + 1`，设置 `left = mid + 1`。

重复上述过程，直到找到目标数字。

**参考代码 1**：

```java
public class Solution extends GuessGame {

    public int guessNumber(int n) {
        int left = 1;
        int right = n;
        while (left <= right) {
            // 写 int mid = (left + right) / 2; 在 left + right 超过 int 范围的时候会溢出
            // 可以改成 int mid = left + (right - left) / 2; 或者改成 int mid = (left + right) >>> 1;
            int mid = left + (right - left) / 2;
            if (guess(mid) == 0) {
                return mid;
            } else if (guess(mid) == -1) {
                // 猜大了，下一轮往小了猜
                right = mid - 1;
            } else {
                // guess(mid) == 1，猜小了，下一轮往大了猜
                left = mid + 1;
            }
        }
        // 由于一定会猜中，代码不会执行到这里，写任意可以编译通过的代码即可
        return -1;
    }

}
```

**复杂度分析**：

+ 时间复杂度：$ O(\log n) $，其中 $ n $ 是数字的范围。二分查找每次将搜索范围缩小到接近原来的一半。设数组长度为$ n $，第一次搜索范围是 $ n $，第二次是 $ \frac{n}{2} $，第三次是 $ \frac{n}{4} $，以此类推，直到搜索区间长度为 1。设搜索次数为 $ k $，则 $ \frac{n}{2^k} = 1 $，得 $ k = \log_2 n $，因此时间复杂度是$ O(\log n) $；
+ 空间复杂度：$ O(1) $。仅使用几个额外的变量（如左右边界变量、中间元素变量），这些变量的空间占用是固定的，不随输入数组大小 $ n $的变化而变化。

**注意**：$ n $ 的范围是 $ 1 \le n \le 2^{31} - 1 $。如果 `mid` 的取值写成 `int mid = (left + right) / 2` ，会看到「力扣」给出「超出时间限制」的提示：

![](https://cdn.nlark.com/yuque/0/2024/png/1354172/1733914983528-2d329d20-d783-471f-a43e-4e8554798b56.png)

这是因为 `left + right` 超过了整形 `int` 的范围，解决办法是：写成 `int mid = left + (right - left) / 2` 或者 `int mid = (left + right) >>> 1`（Java 中有无符号右移，其它编程语言可能不支持）。

:::color4
**阅读提示**：「力扣」上的问题都给出了数据范围，**数据范围是非常重要的题目条件**。因此我们只在 `left + right` 有可能溢出的时候写成 `int mid = left + (right - left) / 2`。理由是：虽然写 `int mid = left + (right - left) / 2` 在很多时候也正确，但是如果 `left + right` 不会整型溢出，写成 `int mid = left + (right - left) / 2` 在计算 `mid` 的时候多一个操作，这个多的操作是没有必要的。

:::

就本题而言，循环可以继续的条件 `left <= right` 可以写成 `left < right`。这是因为根据题目的意思，在搜索区间里一定存在我们要猜的数字，所以 **当 **`**left**`** 与 **`**right**`** 重合的时候，表示已经猜中了答案**，只不过是最后才猜中的。与此同时，在函数 `guessNumber(int n)` 的最后必须写成 `return left` 或者 `return right`，如「参考代码 2」所示。

**参考代码 2**：

```java
public class Solution extends GuessGame {

    public int guessNumber(int n) {
        int left = 1;
        int right = n;
        while (left < right) {
            int mid = left + (right - left) / 2;
            int guessNum = guess(mid);
            if (guessNum == 0) {
                return mid;
            } else if (guessNum == -1) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // 写成 return right; 也能通过
        return left;
    }

}
```

**复杂度分析**：（同「参考代码 1」）

这里还有一个细节：**由于我们在循环体中写了 **`**if (guessNum == 0)**`** ，所以如果没有猜中，或者执行 **`**left = mid + 1**`** 或者执行 **`**right = mid - 1**`**，退出循环以后，都能让 **`**left**`** 与 **`**right**`** 重合**，大家可以使用一个具体的例子代入验证。所以退出循环以后，我们返回 `left` 或者 `right` 都对。

**说明：本题给出的 2 版「参考代码」没有本质区别。**

# 例题 2：「力扣」第 704 题：二分查找（简单）
+ 题目链接：[https://leetcode.cn/problems/binary-search/description/](https://leetcode.cn/problems/binary-search/description/)

<font style="color:rgb(38, 38, 38);">给定一个 </font>`<font style="color:rgba(38, 38, 38, 0.75);">n</font>`<font style="color:rgb(38, 38, 38);"> 个元素有序的（升序）整型数组 </font>`<font style="color:rgba(38, 38, 38, 0.75);">nums</font>`<font style="color:rgb(38, 38, 38);"> 和一个目标值 </font>`<font style="color:rgba(38, 38, 38, 0.75);">target</font>`<font style="color:rgb(38, 38, 38);">  ，写一个函数搜索 </font>`<font style="color:rgba(38, 38, 38, 0.75);">nums</font>`<font style="color:rgb(38, 38, 38);"> 中的 </font>`<font style="color:rgba(38, 38, 38, 0.75);">target</font>`<font style="color:rgb(38, 38, 38);">，如果目标值存在返回下标，否则返回 </font>`<font style="color:rgba(38, 38, 38, 0.75);">-1</font>`<font style="color:rgb(38, 38, 38);">。
</font>**<font style="color:rgb(38, 38, 38);">示例 1:</font>**

```plain
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**<font style="color:rgb(38, 38, 38);">示例 2:</font>**

```plain
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**<font style="color:rgb(38, 38, 38);">提示：</font>**

1. <font style="color:rgb(38, 38, 38);">你可以假设</font><font style="color:rgb(38, 38, 38);"> </font>`<font style="color:rgba(38, 38, 38, 0.75);">nums</font>`<font style="color:rgb(38, 38, 38);"> 中的所有元素是不重复的。</font>
2. `<font style="color:rgba(38, 38, 38, 0.75);">n</font>`<font style="color:rgb(38, 38, 38);"> 将在 </font>`<font style="color:rgba(38, 38, 38, 0.75);">[1, 10000]</font>`<font style="color:rgb(38, 38, 38);">之间。</font>
3. `<font style="color:rgba(38, 38, 38, 0.75);">nums</font>`<font style="color:rgb(38, 38, 38);"> 的每个元素都将在 </font>`<font style="color:rgba(38, 38, 38, 0.75);">[-9999, 9999]</font>`<font style="color:rgb(38, 38, 38);">之间。</font>

## 思路分析
由于 **数组是升序有序的，且无重复元素**，我们可以在数组的开始和末尾分别设置变量 `left` 和 `right` ，再根据 `left` 和 `right` 中间位置的值 `nums[mid]` 与目标元素 `target` 的大小关系，确定目标元素在左半部分还是右半部分，进而更新左右边界，缩小搜索范围，如此下去，直到找到目标元素，或确定目标元素不存在。

根据中间元素 `nums[mid]` 与目标元素 `target` 的大小关系，可以分为以下 3 种情况：

+ **<font style="color:rgb(38, 38, 38);">情况 1：</font>**<font style="color:rgb(38, 38, 38);">如果 </font>`<font style="color:rgb(38, 38, 38);">nums[mid] = target</font>`<font style="color:rgb(38, 38, 38);">，说明找到了目标元素，返回 </font>`<font style="color:rgb(38, 38, 38);">mid</font>`<font style="color:rgb(38, 38, 38);"> ；</font>
+ **<font style="color:rgb(38, 38, 38);">情况 2：</font>**<font style="color:rgb(38, 38, 38);">如果 </font>`<font style="color:rgb(38, 38, 38);">nums[mid] < target</font>`<font style="color:rgb(38, 38, 38);">，说明 </font>`<font style="color:rgb(38, 38, 38);">mid</font>`<font style="color:rgb(38, 38, 38);"> 以及 </font>`<font style="color:rgb(38, 38, 38);">mid</font>`<font style="color:rgb(38, 38, 38);"> 的 </font>**左边**<font style="color:rgb(38, 38, 38);"> 的所有元素一定都比 </font>`<font style="color:rgb(38, 38, 38);">target</font>`<font style="color:rgb(38, 38, 38);"> 小，下一轮搜索区间是 </font>`<font style="color:rgb(38, 38, 38);">[mid + 1..right]</font>`<font style="color:rgb(38, 38, 38);">，此时设置 </font>`<font style="color:rgb(38, 38, 38);">left = mid + 1</font>`<font style="color:rgb(38, 38, 38);">。如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2025/png/1354172/1737089099785-8dd9aa70-4789-4f3d-8756-d0467187ba41.png)

+ **<font style="color:rgb(38, 38, 38);">情况 3：</font>**<font style="color:rgb(38, 38, 38);">如果 </font>`<font style="color:rgb(38, 38, 38);">nums[mid] > target</font>`<font style="color:rgb(38, 38, 38);">，说明 </font>`<font style="color:rgb(38, 38, 38);">mid</font>`<font style="color:rgb(38, 38, 38);"> 以及 </font>`<font style="color:rgb(38, 38, 38);">mid</font>`<font style="color:rgb(38, 38, 38);"> 的 </font>**右边**<font style="color:rgb(38, 38, 38);"> 的所有元素一定都比 </font>`<font style="color:rgb(38, 38, 38);">target</font>`<font style="color:rgb(38, 38, 38);"> 大，下一轮搜索区间是 </font>`<font style="color:rgb(38, 38, 38);">[left..mid - 1]</font>`<font style="color:rgb(38, 38, 38);">，因此设置 </font>`<font style="color:rgb(38, 38, 38);">right = mid - 1</font>`<font style="color:rgb(38, 38, 38);">。如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2025/png/1354172/1737089204084-cea9583d-0dce-453d-912d-e10a87a171be.png)

在 `left` 与 `right` 重合的时候，`left` 与 `right` 重合位置的数值还未被程序看到，还需要继续查找下去，因此循环可以继续的条件是 `left <= right`。退出循环，说明区间里不存在目标元素，返回 -1。

**参考代码**<font style="color:rgb(38, 38, 38);">：</font>

```java
class Solution {

    public int search(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        // 在 [left..right] 里查找 target
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                // 下一轮搜索区间：[left..mid - 1]
                right = mid - 1;
            } else {
                // 此时：nums[mid] < target
                // 下一轮搜索区间：[mid + 1..right]
                left = mid + 1;
            }
        }
        return -1;
    }

}
```

**复杂度分析**<font style="color:rgb(38, 38, 38);">：</font>

+ 时间复杂度：$ O(\log n) $，这里 $ n $ 是数组的长度，
+ 空间复杂度：$ O(1) $。

# 总结
本节给出的 2 个例题是典型的二分查找的问题：

+ 「力扣」第 374 题：猜数字大小（简单）：**查找一个有范围的整数**；
+ 「力扣」第 704 题：二分查找（简单）：在有序数组中查找符合条件的目标元素的值或者下标。

本节的两道「二分查找」问题的特点是：**可以写出一个判别语句，在循环体中直接找到**，当没有找到的时候，或者向左边继续查找，或者向右边继续查找。即：在循环体中把搜索区间分成 3 个部分：

+ 第 1 个部分（中间）：只有一个元素 `mid`；
+ 第 2 个部分（左边区间）：`[left..mid - 1]`；
+ 第 3 个部分（右边区间）：`[mid + 1..right]`。

代码写出来是这样的：

```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    whlile (left <= right) {
        int mid = (left + right) / 2;
        if ( 某个 mid 与 target 的表达式 ) {
            return mid;
        } else if ( 某个 mid 与 target 的表达式 ) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

代码的特点是循环可以继续的条件是 `left <= right`，当 `left` 与 `right` 重合的时候还要继续执行循环体。「力扣」第 374 题由于题目保证了搜索范围里一定有解，所以循环可以继续的条件写成 `left < right`。

大家可千万不要认为「二分查找」的代码都是上面这种固定写法，**具体问题需要具体分析**。下一节我们向大家介绍「二分查找」的 2 个经典问题，通过这 2 个问题向大家介绍其它类型问题二分查找的代码是怎么写出来的。

















